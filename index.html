<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>–ö—Ä–∏–ø—Ç–æ–≥—Ä–∞–º–º–∞ ‚Äî —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞ –º–æ–∑–≥–∞</title>
  <style>
    :root {
      --bg: #0f1220;
      --card: #171a2b;
      --card2: #1c2140;
      --text: #e8ecff;
      --muted: #aab2dd;
      --accent: #6ee7ff;
      --good: #5cffb0;
      --bad: #ff6b8a;
      --warn: #ffd36e;
      --border: rgba(255,255,255,0.10);
      --shadow: 0 10px 30px rgba(0,0,0,0.35);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif;
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: var(--sans);
      color: var(--text);
      background:
        radial-gradient(1200px 600px at 10% 0%, rgba(110,231,255,0.10), transparent 55%),
        radial-gradient(1000px 700px at 90% 10%, rgba(92,255,176,0.08), transparent 60%),
        radial-gradient(900px 600px at 40% 90%, rgba(255,107,138,0.06), transparent 60%),
        var(--bg);
      min-height: 100vh;
    }

    header {
      padding: 18px 16px 8px;
      max-width: 1100px;
      margin: 0 auto;
    }

    .topline {
      display: flex;
      gap: 12px;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
    }

    h1 {
      margin: 0;
      font-size: 20px;
      letter-spacing: 0.3px;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      background: rgba(255,255,255,0.06);
      border: 1px solid var(--border);
      border-radius: 999px;
      color: var(--muted);
      font-size: 13px;
      user-select: none;
    }

    .pill b { color: var(--text); font-weight: 650; }

    main {
      max-width: 1100px;
      margin: 0 auto;
      padding: 8px 16px 24px;
      display: grid;
      grid-template-columns: 1.35fr 0.65fr;
      gap: 14px;
    }

    @media (max-width: 900px) {
      main { grid-template-columns: 1fr; }
    }

    .card {
      background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
      border: 1px solid var(--border);
      border-radius: 18px;
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    .card .hd {
      padding: 14px 14px 10px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      border-bottom: 1px solid var(--border);
      background: rgba(255,255,255,0.03);
    }

    .card .hd .title {
      display: flex;
      flex-direction: column;
      gap: 4px;
      min-width: 240px;
    }

    .subtitle {
      font-size: 13px;
      color: var(--muted);
      line-height: 1.2;
    }

    .actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    button {
      appearance: none;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      border-radius: 12px;
      padding: 9px 12px;
      font-size: 13px;
      cursor: pointer;
      transition: transform .05s ease, background .15s ease, border-color .15s ease;
      user-select: none;
    }
    button:hover { background: rgba(255,255,255,0.10); border-color: rgba(255,255,255,0.18); }
    button:active { transform: translateY(1px); }
    button.primary {
      background: rgba(110,231,255,0.12);
      border-color: rgba(110,231,255,0.35);
    }
    button.primary:hover { background: rgba(110,231,255,0.18); }
    button.good {
      background: rgba(92,255,176,0.12);
      border-color: rgba(92,255,176,0.35);
    }
    button.warn {
      background: rgba(255,211,110,0.10);
      border-color: rgba(255,211,110,0.28);
    }
    button.bad {
      background: rgba(255,107,138,0.10);
      border-color: rgba(255,107,138,0.28);
    }
    button:disabled {
      opacity: .55;
      cursor: not-allowed;
    }

    .body {
      padding: 14px;
    }

    .cipherWrap {
      display: grid;
      gap: 12px;
    }

    .cipher {
      background: rgba(0,0,0,0.18);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 12px;
      font-family: var(--mono);
      line-height: 1.35;
      font-size: 16px;
      min-height: 140px;
      white-space: pre-wrap;
    }

    .grid {
      display: flex;
      flex-wrap: wrap;
      gap: 7px;
      padding-top: 6px;
    }

    .cell {
      width: 36px;
      height: 44px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.05);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      gap: 2px;
      cursor: pointer;
      user-select: none;
      position: relative;
      overflow: hidden;
    }

    .cell.space, .cell.punct {
      width: 16px;
      background: transparent;
      border-color: transparent;
      cursor: default;
    }
    .cell.punct { width: 18px; }
    .cell.punct span { opacity: .9; }

    .cell .top {
      font-size: 11px;
      color: var(--muted);
      opacity: .9;
      letter-spacing: 0.2px;
    }
    .cell .bot {
      font-size: 15px;
      font-weight: 700;
      letter-spacing: 0.3px;
    }

    .cell.active {
      outline: 2px solid rgba(110,231,255,0.55);
      border-color: rgba(110,231,255,0.45);
      background: rgba(110,231,255,0.10);
    }

    .cell.mapped {
      background: rgba(255,255,255,0.08);
    }

    .cell.correct::after {
      content: "";
      position: absolute;
      inset: 0;
      background: rgba(92,255,176,0.10);
      pointer-events: none;
    }
    .cell.wrong::after {
      content: "";
      position: absolute;
      inset: 0;
      background: rgba(255,107,138,0.10);
      pointer-events: none;
    }

    .panel {
      display: grid;
      gap: 12px;
    }

    .stats {
      display: grid;
      gap: 10px;
    }

    .statRow {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    .stat {
      flex: 1;
      min-width: 130px;
      background: rgba(0,0,0,0.18);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 10px 10px;
    }

    .stat .k { color: var(--muted); font-size: 12px; }
    .stat .v { font-size: 18px; font-weight: 750; margin-top: 2px; }

    .mapping {
      background: rgba(0,0,0,0.18);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 10px;
    }

    .mapping h3 {
      margin: 0 0 8px 0;
      font-size: 13px;
      color: var(--muted);
      font-weight: 650;
    }

    .mapGrid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 6px;
    }

    .mapItem {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.05);
      border-radius: 12px;
      font-family: var(--mono);
      font-size: 13px;
    }
    .mapItem .left { color: var(--muted); }
    .mapItem .right { font-weight: 800; letter-spacing: 0.3px; }

    .kbd {
      background: rgba(0,0,0,0.18);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 10px;
    }
    .kbd h3 {
      margin: 0 0 8px 0;
      font-size: 13px;
      color: var(--muted);
      font-weight: 650;
    }

    .keys {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .key {
      width: 34px;
      height: 34px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.06);
      cursor: pointer;
      display: grid;
      place-items: center;
      font-family: var(--mono);
      font-weight: 800;
      user-select: none;
    }
    .key:hover { background: rgba(255,255,255,0.10); }
    .key.special {
      width: auto;
      padding: 0 10px;
      font-family: var(--sans);
      font-weight: 650;
      color: var(--muted);
    }

    .msg {
      margin-top: 10px;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.05);
      color: var(--muted);
      font-size: 13px;
      line-height: 1.3;
      min-height: 42px;
    }

    .msg.ok { border-color: rgba(92,255,176,0.35); color: rgba(92,255,176,0.95); background: rgba(92,255,176,0.08); }
    .msg.bad { border-color: rgba(255,107,138,0.35); color: rgba(255,107,138,0.95); background: rgba(255,107,138,0.08); }
    .msg.warn { border-color: rgba(255,211,110,0.35); color: rgba(255,211,110,0.95); background: rgba(255,211,110,0.08); }

    .footerNote {
      padding: 10px 14px 14px;
      color: var(--muted);
      font-size: 12px;
      line-height: 1.35;
      border-top: 1px solid var(--border);
      background: rgba(255,255,255,0.02);
    }

    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }
  </style>
</head>

<body>
<header>
  <div class="topline">
    <h1>–ö—Ä–∏–ø—Ç–æ–≥—Ä–∞–º–º–∞ ‚Äî —Ä–∞—Å—à–∏—Ñ—Ä—É–π —Ñ—Ä–∞–∑—É</h1>
    <div class="pill">
      –û—á–∫–∏: <b id="scorePill">0</b> ¬∑ –°–µ—Ä–∏—è: <b id="streakPill">0</b>
    </div>
  </div>
</header>

<main>
  <!-- LEFT: puzzle -->
  <section class="card">
    <div class="hd">
      <div class="title">
        <div style="font-weight:750;">–ó–∞–≥–∞–¥–∫–∞</div>
        <div class="subtitle" id="puzzleMeta">–ù–∞–∂–º–∏ –Ω–∞ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—É—é –±—É–∫–≤—É ‚Üí –≤—ã–±–µ—Ä–∏ –ø—Ä–∞–≤–∏–ª—å–Ω—É—é</div>
      </div>
      <div class="actions">
        <button class="primary" id="btnNew">–ù–æ–≤–∞—è</button>
        <button class="good" id="btnDaily">–ï–∂–µ–¥–Ω–µ–≤–Ω–∞—è</button>
        <button class="warn" id="btnHintLetter">–ü–æ–¥—Å–∫–∞–∑–∫–∞: –±—É–∫–≤–∞ (-20)</button>
        <button class="warn" id="btnHintWord">–ü–æ–¥—Å–∫–∞–∑–∫–∞: —Å–ª–æ–≤–æ (-50)</button>
        <button class="bad" id="btnResetMap">–°–±—Ä–æ—Å</button>
        <button id="btnCheck">–ü—Ä–æ–≤–µ—Ä–∏—Ç—å</button>
      </div>
    </div>

    <div class="body">
      <div class="cipherWrap">
        <div class="cipher" id="cipherText"></div>

        <div>
          <div class="subtitle">–†–∞–±–æ—á–µ–µ –ø–æ–ª–µ (–Ω–∞–∂–∏–º–∞–π –Ω–∞ –±–ª–æ–∫–∏):</div>
          <div class="grid" id="cipherGrid" aria-label="cipher grid"></div>
        </div>

        <div class="msg" id="msg">–í—ã–±–µ—Ä–∏ –±—É–∫–≤—É –≤ —Ç–µ–∫—Å—Ç–µ –∏ –Ω–∞–∑–Ω–∞—á—å –µ–π —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ –Ω–∞ –∫–ª–∞–≤–∏–∞—Ç—É—Ä–µ —Å–Ω–∏–∑—É. Backspace ‚Äî –æ—á–∏—Å—Ç–∏—Ç—å –≤—ã–±—Ä–∞–Ω–Ω—É—é –±—É–∫–≤—É.</div>
      </div>
    </div>

    <div class="footerNote">
      –ü–æ–¥—Å–∫–∞–∑–∫–∞: –≤ –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞–º–º–µ <b>–æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–µ –±—É–∫–≤—ã</b> –≤—Å–µ–≥–¥–∞ –æ–∑–Ω–∞—á–∞—é—Ç <b>–æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ –Ω–∞—Å—Ç–æ—è—â–∏–µ –±—É–∫–≤—ã</b>.
      –≠—Ç–æ –∏–≥—Ä–∞ –Ω–∞ –ª–æ–≥–∏–∫—É –∏ –≤–Ω–∏–º–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å.
    </div>
  </section>

  <!-- RIGHT: panel -->
  <aside class="card">
    <div class="hd">
      <div class="title">
        <div style="font-weight:750;">–ü–∞–Ω–µ–ª—å</div>
        <div class="subtitle">–°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è –∏ –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞</div>
      </div>
      <div class="actions">
        <button id="btnReveal">–ü–æ–∫–∞–∑–∞—Ç—å –æ—Ç–≤–µ—Ç</button>
      </div>
    </div>

    <div class="body panel">
      <div class="stats">
        <div class="statRow">
          <div class="stat">
            <div class="k">–ü—Ä–æ–≥—Ä–µ—Å—Å</div>
            <div class="v"><span id="progressVal">0</span>%</div>
          </div>
          <div class="stat">
            <div class="k">–û—à–∏–±–æ–∫ (–ø—Ä–æ–≤–µ—Ä–∫–∞)</div>
            <div class="v"><span id="errorsVal">0</span></div>
          </div>
        </div>
      </div>

      <div class="mapping">
        <h3>–°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è (—à–∏—Ñ—Ä ‚Üí –±—É–∫–≤–∞)</h3>
        <div class="mapGrid" id="mapGrid"></div>
      </div>

      <div class="kbd">
        <h3>–ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞</h3>
        <div class="keys" id="keys"></div>
      </div>

      <div class="msg" id="smallNote">
        –°–æ–≤–µ—Ç: –Ω–∞—á–Ω–∏ —Å —á–∞—Å—Ç—ã—Ö –±—É–∫–≤ ‚Äî –û, –ê, –ï, –ò, –ù, –¢, –°. –ß–∞—Å—Ç–æ –≤—Å—Ç—Ä–µ—á–∞–µ—Ç—Å—è —Å–ª–æ–≤–æ ¬´–ò¬ª, ¬´–ù–ï¬ª, ¬´–ù–ê¬ª, ¬´–í¬ª.
      </div>
    </div>
  </aside>
</main>

<script>
(() => {
  // ====== DATA ======
  // –ú–æ–∂–Ω–æ —Ä–∞—Å—à–∏—Ä—è—Ç—å —Å–ø–∏—Å–æ–∫ —Ñ—Ä–∞–∑ ‚Äî —á–µ–º –±–æ–ª—å—à–µ, —Ç–µ–º –ª—É—á—à–µ.
  // –í–∞–∂–Ω–æ: —Ñ—Ä–∞–∑—ã –Ω–∞ —Ä—É—Å—Å–∫–æ–º, –±–µ–∑ —Ü–∏—Ñ—Ä (–º—ã —à–∏—Ñ—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –±—É–∫–≤—ã).
  const QUOTES = [
    "–£–°–ü–ï–• –ü–†–ò–•–û–î–ò–¢ –ö –¢–ï–ú –ö–¢–û –î–ï–ô–°–¢–í–£–ï–¢",
    "–ë–û–õ–¨–®–û–ô –ü–£–¢–¨ –ù–ê–ß–ò–ù–ê–ï–¢–°–Ø –° –ü–ï–†–í–û–ì–û –®–ê–ì–ê",
    "–ó–ù–ê–ù–ò–Ø –≠–¢–û –°–ò–õ–ê",
    "–°–ï–ì–û–î–ù–Ø –õ–£–ß–®–ï –ß–ï–ú –ó–ê–í–¢–†–ê",
    "–î–ò–°–¶–ò–ü–õ–ò–ù–ê –í–ê–ñ–ù–ï–ï –ú–û–¢–ò–í–ê–¶–ò–ò",
    "–û–®–ò–ë–ö–ò –≠–¢–û –ß–ê–°–¢–¨ –û–ë–£–ß–ï–ù–ò–Ø",
    "–ú–ê–õ–´–ï –®–ê–ì–ò –î–ê–Æ–¢ –ë–û–õ–¨–®–ò–ï –†–ï–ó–£–õ–¨–¢–ê–¢–´",
    "–¢–ï–†–ü–ï–ù–ò–ï –ò –¢–†–£–î –í–°–ï –ü–ï–†–ï–¢–†–£–¢",
    "–ö–¢–û –ù–ï –†–ò–°–ö–£–ï–¢ –¢–û–¢ –ù–ï –í–´–ò–ì–†–´–í–ê–ï–¢",
    "–ü–õ–ê–ù –ë–ï–ó –î–ï–ô–°–¢–í–ò–Ø –≠–¢–û –ú–ï–ß–¢–ê",
    "–õ–£–ß–®–ï –°–î–ï–õ–ê–¢–¨ –ü–õ–û–•–û –ß–ï–ú –ù–ï –°–î–ï–õ–ê–¢–¨ –í–û–û–ë–©–ï",
    "–î–ï–ù–¨–ì–ò –õ–Æ–ë–Ø–¢ –°–ß–ï–¢",
    "–î–û–í–ï–†–Ø–ô –ù–û –ü–†–û–í–ï–†–Ø–ô",
    "–í–†–ï–ú–Ø –≠–¢–û –°–ê–ú–´–ô –î–û–†–û–ì–û–ô –†–ï–°–£–†–°",
    "–¢–´ –°–¢–ê–ù–û–í–ò–®–¨–°–Ø –¢–ï–ú –ß–¢–û –ü–û–í–¢–û–†–Ø–ï–®–¨ –ö–ê–ñ–î–´–ô –î–ï–ù–¨"
  ];

  const RU = "–ê–ë–í–ì–î–ï–Å–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø";
  const LETTER_SET = new Set(RU.split(""));

  // ====== STATE ======
  const STORAGE_KEY = "cryptogram_v1_state";
  let state = loadState() || {
    score: 0,
    streak: 0,
    lastSolvedDaily: null, // YYYY-MM-DD
    current: null
  };

  // current puzzle structure:
  // {
  //   mode: "new" | "daily",
  //   id: string,
  //   plain: string,
  //   cipher: string,
  //   sub: { [plainLetter]: cipherLetter }, // encryption map
  //   inv: { [cipherLetter]: plainLetter }, // correct inverse map
  //   guess: { [cipherLetter]: plainLetter }, // player's mapping
  //   revealed: Set(cipherLetter) // letters opened by hints (locked)
  // }
  if (!state.current) {
    state.current = makeRandomPuzzle();
    saveState();
  }

  // ====== DOM ======
  const elCipherText = document.getElementById("cipherText");
  const elCipherGrid = document.getElementById("cipherGrid");
  const elMsg = document.getElementById("msg");
  const elMapGrid = document.getElementById("mapGrid");
  const elKeys = document.getElementById("keys");
  const elProgressVal = document.getElementById("progressVal");
  const elErrorsVal = document.getElementById("errorsVal");
  const elScorePill = document.getElementById("scorePill");
  const elStreakPill = document.getElementById("streakPill");
  const elPuzzleMeta = document.getElementById("puzzleMeta");

  const btnNew = document.getElementById("btnNew");
  const btnDaily = document.getElementById("btnDaily");
  const btnHintLetter = document.getElementById("btnHintLetter");
  const btnHintWord = document.getElementById("btnHintWord");
  const btnResetMap = document.getElementById("btnResetMap");
  const btnCheck = document.getElementById("btnCheck");
  const btnReveal = document.getElementById("btnReveal");

  let activeCipherLetter = null; // selected cipher letter

  // ====== UTIL ======
  function todayISO() {
    const d = new Date();
    const yyyy = d.getFullYear();
    const mm = String(d.getMonth()+1).padStart(2, "0");
    const dd = String(d.getDate()).padStart(2, "0");
    return `${yyyy}-${mm}-${dd}`;
  }

  function hashStringToInt(s) {
    // simple deterministic hash
    let h = 2166136261;
    for (let i = 0; i < s.length; i++) {
      h ^= s.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return (h >>> 0);
  }

  function seededRandom(seed) {
    // mulberry32
    let t = seed >>> 0;
    return function() {
      t += 0x6D2B79F5;
      let x = Math.imul(t ^ (t >>> 15), 1 | t);
      x ^= x + Math.imul(x ^ (x >>> 7), 61 | x);
      return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
    };
  }

  function pickRandom(arr, rnd = Math.random) {
    return arr[Math.floor(rnd() * arr.length)];
  }

  function normalizeText(s) {
    // uppercase + collapse spaces
    return s
      .toUpperCase()
      .replace(/\s+/g, " ")
      .trim();
  }

  function makeSubstitutionMap(rnd = Math.random) {
    // creates a random permutation for RU letters; keeps letters mapped to different letters (no fixed points) where possible.
    const letters = RU.split("");
    const perm = letters.slice();

    // Fisher-Yates shuffle
    for (let i = perm.length - 1; i > 0; i--) {
      const j = Math.floor(rnd() * (i + 1));
      [perm[i], perm[j]] = [perm[j], perm[i]];
    }

    // avoid fixed points: if perm[i] === letters[i], try swap with next
    for (let i = 0; i < letters.length; i++) {
      if (perm[i] === letters[i]) {
        const j = (i + 1) % letters.length;
        [perm[i], perm[j]] = [perm[j], perm[i]];
      }
    }

    const sub = {};
    for (let i = 0; i < letters.length; i++) sub[letters[i]] = perm[i];
    return sub;
  }

  function encrypt(plain, sub) {
    let out = "";
    for (const ch of plain) {
      if (LETTER_SET.has(ch)) out += sub[ch];
      else out += ch;
    }
    return out;
  }

  function invertMap(sub) {
    const inv = {};
    for (const [p, c] of Object.entries(sub)) inv[c] = p;
    return inv;
  }

  function getUniqueCipherLetters(cipher) {
    const set = new Set();
    for (const ch of cipher) if (LETTER_SET.has(ch)) set.add(ch);
    return Array.from(set).sort();
  }

  function getWordsIndices(text) {
    // returns array of {start,end} index slices for words (letters only)
    const res = [];
    let i = 0;
    while (i < text.length) {
      while (i < text.length && !LETTER_SET.has(text[i])) i++;
      if (i >= text.length) break;
      const start = i;
      while (i < text.length && LETTER_SET.has(text[i])) i++;
      const end = i;
      res.push({start, end});
    }
    return res;
  }

  function applyGuessToCipherText(cipher, guess) {
    // produce display string where guessed letters shown, unknown as "¬∑"
    let out = "";
    for (const ch of cipher) {
      if (LETTER_SET.has(ch)) {
        out += (guess[ch] || "¬∑");
      } else {
        out += ch;
      }
    }
    return out;
  }

  function countFilled(cipher, guess) {
    let total = 0, filled = 0;
    for (const ch of cipher) {
      if (LETTER_SET.has(ch)) {
        total++;
        if (guess[ch]) filled++;
      }
    }
    return { total, filled };
  }

  function showMessage(text, kind = "") {
    elMsg.className = "msg" + (kind ? " " + kind : "");
    elMsg.textContent = text;
  }

  function showSmallNote(text, kind = "") {
    const el = document.getElementById("smallNote");
    el.className = "msg" + (kind ? " " + kind : "");
    el.textContent = text;
  }

  function loadState() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return null;
      const s = JSON.parse(raw);

      // revive Set
      if (s?.current?.revealed && Array.isArray(s.current.revealed)) {
        s.current.revealed = new Set(s.current.revealed);
      } else if (s?.current?.revealed && typeof s.current.revealed === "object" && s.current.revealed !== null) {
        // ignore
      } else if (s?.current) {
        s.current.revealed = new Set();
      }
      return s;
    } catch {
      return null;
    }
  }

  function saveState() {
    const s = structuredClone(state);
    // serialize Set
    if (s?.current?.revealed instanceof Set) s.current.revealed = Array.from(s.current.revealed);
    localStorage.setItem(STORAGE_KEY, JSON.stringify(s));
  }

  // ====== PUZZLE BUILDERS ======
  function makeRandomPuzzle() {
    const plain = normalizeText(pickRandom(QUOTES));
    const sub = makeSubstitutionMap(Math.random);
    const cipher = encrypt(plain, sub);
    return {
      mode: "new",
      id: "rnd_" + Date.now(),
      plain,
      cipher,
      sub,
      inv: invertMap(sub),
      guess: {},
      revealed: new Set()
    };
  }

  function makeDailyPuzzle() {
    const day = todayISO();
    const seed = hashStringToInt("daily:" + day);
    const rnd = seededRandom(seed);
    const plain = normalizeText(pickRandom(QUOTES, rnd));
    const sub = makeSubstitutionMap(rnd);
    const cipher = encrypt(plain, sub);
    return {
      mode: "daily",
      id: "daily_" + day,
      plain,
      cipher,
      sub,
      inv: invertMap(sub),
      guess: {},
      revealed: new Set()
    };
  }

  // ====== RENDER ======
  function render() {
    // top pills
    elScorePill.textContent = String(state.score);
    elStreakPill.textContent = String(state.streak);

    // meta
    const modeLabel = state.current.mode === "daily" ? "–ï–∂–µ–¥–Ω–µ–≤–Ω–∞—è" : "–û–±—ã—á–Ω–∞—è";
    elPuzzleMeta.textContent = `${modeLabel} ¬∑ –ù–∞–∂–º–∏ –Ω–∞ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—É—é –±—É–∫–≤—É ‚Üí –≤—ã–±–µ—Ä–∏ –ø—Ä–∞–≤–∏–ª—å–Ω—É—é`;

    // cipher text (raw)
    elCipherText.textContent =
      "–®–∏—Ñ—Ä:\n" +
      state.current.cipher +
      "\n\n–í–∞—à –æ—Ç–≤–µ—Ç:\n" +
      applyGuessToCipherText(state.current.cipher, state.current.guess);

    // grid
    buildCipherGrid();

    // mapping panel
    buildMappingPanel();

    // keyboard
    buildKeyboard();

    // progress
    const { total, filled } = countFilled(state.current.cipher, state.current.guess);
    const pct = total ? Math.floor((filled / total) * 100) : 0;
    elProgressVal.textContent = String(pct);

    // errors reset
    elErrorsVal.textContent = "0";

    // hint buttons state
    btnHintLetter.disabled = state.score < 20;
    btnHintWord.disabled = state.score < 50;

    // daily solved indicator
    if (state.current.mode === "daily") {
      const day = todayISO();
      if (state.lastSolvedDaily === day) {
        showSmallNote("–°–µ–≥–æ–¥–Ω—è—à–Ω—è—è –µ–∂–µ–¥–Ω–µ–≤–Ω–∞—è –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞–º–º–∞ —É–∂–µ —Ä–µ—à–µ–Ω–∞. –ú–æ–∂–Ω–æ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∞—Ç—å—Å—è –≤ –æ–±—ã—á–Ω–æ–º —Ä–µ–∂–∏–º–µ üôÇ", "ok");
      } else {
        showSmallNote("–ï–∂–µ–¥–Ω–µ–≤–Ω–∞—è –∑–∞–¥–∞—á–∞: —Ä–µ—à–∏ —Ñ—Ä–∞–∑—É —Å–µ–≥–æ–¥–Ω—è –∏ –ø–æ–ª—É—á–∏ –±–æ–Ω—É—Å +100 –æ—á–∫–æ–≤!", "");
      }
    } else {
      showSmallNote("–°–æ–≤–µ—Ç: –Ω–∞—á–Ω–∏ —Å —á–∞—Å—Ç—ã—Ö –±—É–∫–≤ ‚Äî –û, –ê, –ï, –ò, –ù, –¢, –°. –ß–∞—Å—Ç–æ –≤—Å—Ç—Ä–µ—á–∞–µ—Ç—Å—è —Å–ª–æ–≤–æ ¬´–ò¬ª, ¬´–ù–ï¬ª, ¬´–ù–ê¬ª, ¬´–í¬ª.", "");
    }
  }

  function buildCipherGrid() {
    elCipherGrid.innerHTML = "";
    const cipher = state.current.cipher;

    for (let i = 0; i < cipher.length; i++) {
      const ch = cipher[i];

      if (ch === " ") {
        const div = document.createElement("div");
        div.className = "cell space";
        elCipherGrid.appendChild(div);
        continue;
      }

      if (!LETTER_SET.has(ch)) {
        const div = document.createElement("div");
        div.className = "cell punct";
        const span = document.createElement("span");
        span.textContent = ch;
        div.appendChild(span);
        elCipherGrid.appendChild(div);
        continue;
      }

      const top = ch; // cipher letter
      const bot = state.current.guess[ch] || "¬∑";

      const div = document.createElement("div");
      div.className = "cell" + (state.current.guess[ch] ? " mapped" : "");
      div.dataset.c = ch;

      if (activeCipherLetter === ch) div.classList.add("active");

      const t = document.createElement("div");
      t.className = "top";
      t.textContent = top;

      const b = document.createElement("div");
      b.className = "bot";
      b.textContent = bot;

      div.appendChild(t);
      div.appendChild(b);

      div.addEventListener("click", () => {
        if (activeCipherLetter === ch) {
          activeCipherLetter = null;
        } else {
          activeCipherLetter = ch;
        }
        render();
      });

      elCipherGrid.appendChild(div);
    }
  }

  function buildMappingPanel() {
    elMapGrid.innerHTML = "";
    const letters = getUniqueCipherLetters(state.current.cipher);
    const guess = state.current.guess;

    for (const c of letters) {
      const item = document.createElement("div");
      item.className = "mapItem";
      item.title = "–ù–∞–∂–º–∏, —á—Ç–æ–±—ã –≤—ã–±—Ä–∞—Ç—å –±—É–∫–≤—É –≤ —Ç–µ–∫—Å—Ç–µ";

      const left = document.createElement("div");
      left.className = "left";
      left.textContent = c + " ‚Üí";

      const right = document.createElement("div");
      right.className = "right";
      right.textContent = guess[c] || "¬∑";

      item.appendChild(left);
      item.appendChild(right);

      item.addEventListener("click", () => {
        activeCipherLetter = c;
        render();
      });

      elMapGrid.appendChild(item);
    }
  }

  function buildKeyboard() {
    elKeys.innerHTML = "";

    const makeKey = (label, onClick, extraClass="") => {
      const k = document.createElement("div");
      k.className = "key" + (extraClass ? " " + extraClass : "");
      k.textContent = label;
      k.addEventListener("click", onClick);
      return k;
    };

    // letter keys
    for (const L of RU) {
      const k = makeKey(L, () => assignLetter(L));
      elKeys.appendChild(k);
    }

    // special keys
    elKeys.appendChild(makeKey("‚å´", () => clearActive(), "special"));
    elKeys.appendChild(makeKey("–°–ª—É—á.", () => smartRandomFillOne(), "special"));
    elKeys.appendChild(makeKey("–û—á–∏—Å—Ç–∏—Ç—å –≤—Å—ë", () => resetMap(), "special"));
  }

  // ====== GAME ACTIONS ======
  function assignLetter(plainLetter) {
    if (!activeCipherLetter) {
      showMessage("–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—É—é –±—É–∫–≤—É –≤ —Ç–µ–∫—Å—Ç–µ (–≤–µ—Ä—Ö–Ω—è—è –º–∞–ª–µ–Ω—å–∫–∞—è –±—É–∫–≤–∞).", "warn");
      return;
    }

    // If this cipher letter is revealed (locked), block manual changes
    if (state.current.revealed.has(activeCipherLetter)) {
      showMessage("–≠—Ç–∞ –±—É–∫–≤–∞ –æ—Ç–∫—Ä—ã—Ç–∞ –ø–æ–¥—Å–∫–∞–∑–∫–æ–π –∏ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–∞. –í—ã–±–µ—Ä–∏ –¥—Ä—É–≥—É—é.", "warn");
      return;
    }

    // prevent mapping two cipher letters to same plain letter (optional but helpful)
    // if some other cipher already mapped to this plainLetter, we can swap or deny.
    const existing = Object.entries(state.current.guess).find(([c, p]) => p === plainLetter && c !== activeCipherLetter);
    if (existing) {
      showMessage(`–ë—É–∫–≤–∞ "${plainLetter}" —É–∂–µ –Ω–∞–∑–Ω–∞—á–µ–Ω–∞ –¥–ª—è "${existing[0]}". –°–Ω–∞—á–∞–ª–∞ –æ—á–∏—Å—Ç–∏ –µ—ë (‚å´) –∏–ª–∏ –≤—ã–±–µ—Ä–∏ –¥—Ä—É–≥—É—é –±—É–∫–≤—É.`, "warn");
      return;
    }

    state.current.guess[activeCipherLetter] = plainLetter;
    saveState();
    showMessage(`–ù–∞–∑–Ω–∞—á–µ–Ω–æ: ${activeCipherLetter} ‚Üí ${plainLetter}`, "");
    render();
  }

  function clearActive() {
    if (!activeCipherLetter) {
      showMessage("–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—É—é –±—É–∫–≤—É –≤ —Ç–µ–∫—Å—Ç–µ.", "warn");
      return;
    }
    if (state.current.revealed.has(activeCipherLetter)) {
      showMessage("–≠—Ç–∞ –±—É–∫–≤–∞ –æ—Ç–∫—Ä—ã—Ç–∞ –ø–æ–¥—Å–∫–∞–∑–∫–æ–π –∏ –Ω–µ –æ—á–∏—â–∞–µ—Ç—Å—è.", "warn");
      return;
    }
    delete state.current.guess[activeCipherLetter];
    saveState();
    showMessage(`–û—á–∏—â–µ–Ω–æ: ${activeCipherLetter}`, "");
    render();
  }

  function resetMap() {
    const keep = {};
    // keep revealed letters
    for (const c of state.current.revealed) {
      keep[c] = state.current.inv[c];
    }
    state.current.guess = keep;
    activeCipherLetter = null;
    saveState();
    showMessage("–°–±—Ä–æ—à–µ–Ω–æ. –û—Ç–∫—Ä—ã—Ç—ã–µ –ø–æ–¥—Å–∫–∞–∑–∫–∞–º–∏ –±—É–∫–≤—ã —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã.", "");
    render();
  }

  function smartRandomFillOne() {
    // fill one random cipher letter with a random not-yet-used plain letter
    const letters = getUniqueCipherLetters(state.current.cipher);
    const freeCipher = letters.filter(c => !state.current.guess[c] && !state.current.revealed.has(c));
    if (freeCipher.length === 0) {
      showMessage("–ù–µ—Ç —Å–≤–æ–±–æ–¥–Ω—ã—Ö –±—É–∫–≤ –¥–ª—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è.", "warn");
      return;
    }
    const c = freeCipher[Math.floor(Math.random() * freeCipher.length)];
    const usedPlain = new Set(Object.values(state.current.guess));
    const freePlain = RU.split("").filter(p => !usedPlain.has(p));
    if (freePlain.length === 0) return;
    const p = freePlain[Math.floor(Math.random() * freePlain.length)];
    state.current.guess[c] = p;
    activeCipherLetter = c;
    saveState();
    showMessage(`–°–ª—É—á–∞–π–Ω–æ: ${c} ‚Üí ${p} (–º–æ–∂–Ω–æ –∏–∑–º–µ–Ω–∏—Ç—å)`, "");
    render();
  }

  function checkSolution() {
    const cipher = state.current.cipher;
    const guess = state.current.guess;
    const inv = state.current.inv;

    let errors = 0;
    let compared = 0;

    // mark grid cells as correct/wrong based on current guesses
    const cells = elCipherGrid.querySelectorAll(".cell[data-c]");
    cells.forEach(cell => {
      cell.classList.remove("correct", "wrong");
    });

    for (let i = 0; i < cipher.length; i++) {
      const ch = cipher[i];
      if (!LETTER_SET.has(ch)) continue;

      const g = guess[ch];
      if (!g) continue;

      compared++;
      const correct = inv[ch];
      if (g !== correct) errors++;
    }

    elErrorsVal.textContent = String(errors);

    // paint cells
    cells.forEach(cell => {
      const c = cell.dataset.c;
      if (!c) return;
      const g = guess[c];
      if (!g) return;
      const correct = inv[c];
      if (g === correct) cell.classList.add("correct");
      else cell.classList.add("wrong");
    });

    if (compared === 0) {
      showMessage("–ü–æ–∫–∞ –Ω–µ—á–µ–≥–æ –ø—Ä–æ–≤–µ—Ä—è—Ç—å: –Ω–∞–∑–Ω–∞—á—å —Ö–æ—Ç—è –±—ã –æ–¥–Ω—É –±—É–∫–≤—É.", "warn");
      return;
    }

    if (isFullySolved()) {
      onSolved();
      return;
    }

    if (errors === 0) showMessage("–ü—Ä–æ–≤–µ—Ä–∫–∞: –ø–æ–∫–∞ –æ—à–∏–±–æ–∫ –Ω–µ—Ç. –ü—Ä–æ–¥–æ–ª–∂–∞–π üôÇ", "ok");
    else showMessage(`–ü—Ä–æ–≤–µ—Ä–∫–∞: –Ω–∞–π–¥–µ–Ω–æ –æ—à–∏–±–æ–∫ ‚Äî ${errors}. –ò—Å–ø—Ä–∞–≤—å –≤—ã–¥–µ–ª–µ–Ω–Ω—ã–µ –±—É–∫–≤—ã.`, "bad");
  }

  function isFullySolved() {
    const inv = state.current.inv;
    const letters = getUniqueCipherLetters(state.current.cipher);
    // solved if every used cipher letter has correct mapping
    for (const c of letters) {
      const need = inv[c];
      const g = state.current.guess[c];
      if (!g || g !== need) return false;
    }
    // also ensure ciphertext letters count > 0
    return letters.length > 0;
  }

  function onSolved() {
    // award score
    const base = 60;
    let bonus = 0;

    if (state.current.mode === "daily") {
      const day = todayISO();
      if (state.lastSolvedDaily !== day) {
        bonus += 100;
        state.lastSolvedDaily = day;
      }
    }

    // streak: increment on solve
    state.streak = (state.streak || 0) + 1;

    // hint penalty already applied; now add reward
    state.score += (base + bonus);

    saveState();

    showMessage(`‚úÖ –†–µ—à–µ–Ω–æ! +${base}${bonus ? " +"+bonus+" (–µ–∂–µ–¥–Ω–µ–≤–Ω—ã–π –±–æ–Ω—É—Å)" : ""} –æ—á–∫–æ–≤. –°–µ—Ä–∏—è: ${state.streak}`, "ok");

    // auto-generate next puzzle (in same mode if daily not solved? keep as is; user can choose)
    // keep current so user can see; but we can offer next by enabling New button etc.
    render();
  }

  function revealAnswer() {
    // fill all correct
    const inv = state.current.inv;
    const letters = getUniqueCipherLetters(state.current.cipher);
    for (const c of letters) state.current.guess[c] = inv[c];
    activeCipherLetter = null;
    saveState();
    showMessage("–û—Ç–≤–µ—Ç –ø–æ–∫–∞–∑–∞–Ω. –¢–µ–ø–µ—Ä—å –º–æ–∂–µ—à—å –Ω–∞–∂–∞—Ç—å ¬´–ù–æ–≤–∞—è¬ª –∏ —Ä–µ—à–∞—Ç—å –¥–∞–ª—å—à–µ.", "warn");
    render();
  }

  function hintOneLetter() {
    if (state.score < 20) {
      showMessage("–ù–µ —Ö–≤–∞—Ç–∞–µ—Ç –æ—á–∫–æ–≤ –Ω–∞ –ø–æ–¥—Å–∫–∞–∑–∫—É (–Ω—É–∂–Ω–æ 20).", "warn");
      return;
    }

    const letters = getUniqueCipherLetters(state.current.cipher);
    const candidates = letters.filter(c => !state.current.guess[c]);
    if (candidates.length === 0) {
      showMessage("–í—Å–µ –±—É–∫–≤—ã —É–∂–µ –Ω–∞–∑–Ω–∞—á–µ–Ω—ã.", "warn");
      return;
    }

    const c = candidates[Math.floor(Math.random() * candidates.length)];
    const correct = state.current.inv[c];

    state.score -= 20;
    state.current.guess[c] = correct;
    state.current.revealed.add(c); // lock this mapping
    activeCipherLetter = c;
    saveState();

    showMessage(`–ü–æ–¥—Å–∫–∞–∑–∫–∞: ${c} ‚Üí ${correct} (–∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–æ)`, "ok");
    render();
  }

  function hintOneWord() {
    if (state.score < 50) {
      showMessage("–ù–µ —Ö–≤–∞—Ç–∞–µ—Ç –æ—á–∫–æ–≤ –Ω–∞ –ø–æ–¥—Å–∫–∞–∑–∫—É (–Ω—É–∂–Ω–æ 50).", "warn");
      return;
    }

    // choose a word in cipher and reveal all its letters (those not yet guessed)
    const cipher = state.current.cipher;
    const words = getWordsIndices(cipher);
    if (words.length === 0) {
      showMessage("–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ —Å–ª–æ–≤–æ –¥–ª—è –ø–æ–¥—Å–∫–∞–∑–∫–∏.", "warn");
      return;
    }

    // pick a word with some unknown letters
    const shuffled = words.slice().sort(() => Math.random() - 0.5);
    let target = null;
    for (const w of shuffled) {
      let hasUnknown = false;
      for (let i = w.start; i < w.end; i++) {
        const ch = cipher[i];
        if (LETTER_SET.has(ch) && !state.current.guess[ch]) { hasUnknown = true; break; }
      }
      if (hasUnknown) { target = w; break; }
    }

    if (!target) {
      showMessage("–í—Å–µ —Å–ª–æ–≤–∞ —É–∂–µ —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–∏ —Ä–∞—Å–∫—Ä—ã—Ç—ã (–±—É–∫–≤—ã –Ω–∞–∑–Ω–∞—á–µ–Ω—ã).", "warn");
      return;
    }

    state.score -= 50;

    for (let i = target.start; i < target.end; i++) {
      const c = cipher[i];
      if (!LETTER_SET.has(c)) continue;
      const correct = state.current.inv[c];
      state.current.guess[c] = correct;
      state.current.revealed.add(c);
    }

    activeCipherLetter = null;
    saveState();

    showMessage("–ü–æ–¥—Å–∫–∞–∑–∫–∞: –æ–¥–Ω–æ —Å–ª–æ–≤–æ —Ä–∞—Å–∫—Ä—ã—Ç–æ (–±—É–∫–≤—ã –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã).", "ok");
    render();
  }

  // ====== BUTTONS ======
  btnNew.addEventListener("click", () => {
    state.current = makeRandomPuzzle();
    activeCipherLetter = null;
    saveState();
    showMessage("–ù–æ–≤–∞—è –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞–º–º–∞ —Å–æ–∑–¥–∞–Ω–∞. –£–¥–∞—á–∏!", "");
    render();
  });

  btnDaily.addEventListener("click", () => {
    state.current = makeDailyPuzzle();
    activeCipherLetter = null;

    // If user already solved today's daily, keep their score/streak but still allow play
    saveState();
    showMessage("–ï–∂–µ–¥–Ω–µ–≤–Ω–∞—è –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞–º–º–∞ –∑–∞–≥—Ä—É–∂–µ–Ω–∞.", "");
    render();
  });

  btnHintLetter.addEventListener("click", hintOneLetter);
  btnHintWord.addEventListener("click", hintOneWord);
  btnResetMap.addEventListener("click", resetMap);
  btnCheck.addEventListener("click", checkSolution);
  btnReveal.addEventListener("click", revealAnswer);

  // ====== KEYBOARD EVENTS ======
  window.addEventListener("keydown", (e) => {
    const key = e.key;

    if (key === "Backspace") {
      e.preventDefault();
      clearActive();
      return;
    }
    if (key === "Escape") {
      activeCipherLetter = null;
      showMessage("–í—ã–±–æ—Ä —Å–Ω—è—Ç.", "");
      render();
      return;
    }

    // allow typing russian letters
    const upper = key.toUpperCase();
    if (upper.length === 1 && LETTER_SET.has(upper)) {
      assignLetter(upper);
      return;
    }
  });

  // ====== INIT ======
  // ensure revealed set exists after load
  if (!(state.current.revealed instanceof Set)) {
    state.current.revealed = new Set(Array.isArray(state.current.revealed) ? state.current.revealed : []);
  }

  render();

})();
</script>
</body>
</html>