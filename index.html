<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>–ö—Ä–∏–ø—Ç–æ–≥—Ä–∞–º–º–∞ ‚Äî —Ä–∞—Å—à–∏—Ñ—Ä—É–π —Ñ—Ä–∞–∑—É</title>
  <style>
    :root{
      --bg:#0f1220; --card:#171a2b; --text:#e8ecff; --muted:#aab2dd;
      --accent:#6ee7ff; --good:#5cffb0; --bad:#ff6b8a; --warn:#ffd36e;
      --border:rgba(255,255,255,.10); --shadow:0 10px 30px rgba(0,0,0,.35);
      --mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
      --sans:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial,"Noto Sans","Liberation Sans",sans-serif;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family:var(--sans); color:var(--text); background:var(--bg);
      background:
        radial-gradient(1200px 600px at 10% 0%, rgba(110,231,255,0.10), transparent 55%),
        radial-gradient(1000px 700px at 90% 10%, rgba(92,255,176,0.08), transparent 60%),
        radial-gradient(900px 600px at 40% 90%, rgba(255,107,138,0.06), transparent 60%),
        var(--bg);
      min-height:100vh;
      padding-bottom: calc(92px + env(safe-area-inset-bottom)); /* –º–µ—Å—Ç–æ –ø–æ–¥ –Ω–∏–∂–Ω—é—é –ø–∞–Ω–µ–ª—å */
    }

    header{max-width:1100px;margin:0 auto;padding:14px 14px 6px}
    .topline{display:flex;gap:10px;align-items:center;justify-content:space-between;flex-wrap:wrap}
    h1{margin:0;font-size:18px;letter-spacing:.2px}
    .pill{display:inline-flex;gap:8px;align-items:center;padding:8px 12px;border-radius:999px;
      background:rgba(255,255,255,.06);border:1px solid var(--border);color:var(--muted);font-size:13px}
    .pill b{color:var(--text)}

    main{max-width:1100px;margin:0 auto;padding:8px 14px 18px;display:grid;grid-template-columns:1.25fr .75fr;gap:12px}
    @media (max-width: 980px){ main{grid-template-columns:1fr} }

    .card{background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border:1px solid var(--border);border-radius:18px;box-shadow:var(--shadow);overflow:hidden}
    .hd{padding:12px 12px 10px;display:flex;align-items:center;justify-content:space-between;gap:10px;
      border-bottom:1px solid var(--border);background:rgba(255,255,255,.03)}
    .title{display:flex;flex-direction:column;gap:4px;min-width:220px}
    .subtitle{font-size:13px;color:var(--muted);line-height:1.25}
    .actions{display:flex;gap:8px;flex-wrap:wrap;justify-content:flex-end}
    button{appearance:none;border:1px solid var(--border);background:rgba(255,255,255,.06);color:var(--text);
      border-radius:14px;padding:10px 12px;font-size:13px;cursor:pointer;transition:.15s;user-select:none}
    button:hover{background:rgba(255,255,255,.10);border-color:rgba(255,255,255,.18)}
    button:active{transform:translateY(1px)}
    button.primary{background:rgba(110,231,255,.12);border-color:rgba(110,231,255,.35)}
    button.good{background:rgba(92,255,176,.12);border-color:rgba(92,255,176,.35)}
    button.warn{background:rgba(255,211,110,.10);border-color:rgba(255,211,110,.28)}
    button.bad{background:rgba(255,107,138,.10);border-color:rgba(255,107,138,.28)}
    button:disabled{opacity:.55;cursor:not-allowed}

    .body{padding:12px}
    .cipher{
      background:rgba(0,0,0,.18);border:1px solid var(--border);border-radius:16px;
      padding:12px;font-family:var(--mono);line-height:1.35;font-size:16px;white-space:pre-wrap
    }

    .grid{display:flex;flex-wrap:wrap;gap:7px;padding-top:8px}
    .cell{
      width:44px;height:52px;border-radius:14px;border:1px solid var(--border);
      background:rgba(255,255,255,.05);display:flex;flex-direction:column;align-items:center;justify-content:center;
      gap:3px;cursor:pointer;user-select:none;position:relative;overflow:hidden
    }
    .cell .top{font-size:12px;color:var(--muted);letter-spacing:.2px}
    .cell .bot{font-size:16px;font-weight:800;letter-spacing:.3px}
    .cell.active{outline:2px solid rgba(110,231,255,.55);border-color:rgba(110,231,255,.45);background:rgba(110,231,255,.10)}
    .cell.mapped{background:rgba(255,255,255,.08)}
    .cell.space,.cell.punct{width:16px;height:52px;background:transparent;border-color:transparent;cursor:default}
    .cell.punct{width:20px}
    .cell.correct::after{content:"";position:absolute;inset:0;background:rgba(92,255,176,.10)}
    .cell.wrong::after{content:"";position:absolute;inset:0;background:rgba(255,107,138,.10)}

    .panel{display:grid;gap:10px}
    .statRow{display:flex;gap:10px;flex-wrap:wrap}
    .stat{flex:1;min-width:140px;background:rgba(0,0,0,.18);border:1px solid var(--border);border-radius:14px;padding:10px}
    .stat .k{color:var(--muted);font-size:12px}
    .stat .v{font-size:18px;font-weight:800;margin-top:2px}

    .mapping,.kbd{background:rgba(0,0,0,.18);border:1px solid var(--border);border-radius:16px;padding:10px}
    .mapping h3,.kbd h3{margin:0 0 8px 0;font-size:13px;color:var(--muted);font-weight:700}
    .mapGrid{display:grid;grid-template-columns:repeat(2,1fr);gap:6px}
    @media (max-width: 520px){ .mapGrid{grid-template-columns:1fr} }
    .mapItem{display:flex;justify-content:space-between;gap:10px;align-items:center;padding:10px 10px;
      border:1px solid var(--border);background:rgba(255,255,255,.05);border-radius:14px;font-family:var(--mono);font-size:13px}
    .mapItem .left{color:var(--muted)}
    .mapItem .right{font-weight:900;letter-spacing:.3px}

    /* –ú–æ–±–∏–ª—å–Ω–∞—è –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞: –∫—Ä—É–ø–Ω–µ–µ, –≤ 8 –∫–æ–ª–æ–Ω–æ–∫ –Ω–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–µ */
    .keys{display:grid;gap:6px;grid-template-columns:repeat(11,1fr)}
    @media (max-width: 980px){ .keys{grid-template-columns:repeat(10,1fr)} }
    @media (max-width: 520px){ .keys{grid-template-columns:repeat(8,1fr)} }

    .key{
      height:44px;border-radius:14px;border:1px solid var(--border);
      background:rgba(255,255,255,.06);cursor:pointer;display:grid;place-items:center;
      font-family:var(--mono);font-weight:900;user-select:none
    }
    .key:hover{background:rgba(255,255,255,.10)}
    .key.special{grid-column: span 2; font-family:var(--sans); font-weight:750; color:var(--muted)}
    @media (max-width: 520px){ .key.special{grid-column: span 4;} }

    .msg{
      margin-top:10px;padding:10px 12px;border-radius:14px;border:1px solid var(--border);
      background:rgba(255,255,255,.05);color:var(--muted);font-size:13px;line-height:1.3;min-height:42px
    }
    .msg.ok{border-color:rgba(92,255,176,.35);color:rgba(92,255,176,.95);background:rgba(92,255,176,.08)}
    .msg.bad{border-color:rgba(255,107,138,.35);color:rgba(255,107,138,.95);background:rgba(255,107,138,.08)}
    .msg.warn{border-color:rgba(255,211,110,.35);color:rgba(255,211,110,.95);background:rgba(255,211,110,.08)}

    .footerNote{
      padding:10px 12px 14px;color:var(--muted);font-size:12px;line-height:1.35;
      border-top:1px solid var(--border);background:rgba(255,255,255,.02)
    }

    /* –ù–∏–∂–Ω—è—è –ø–∞–Ω–µ–ª—å –¥–µ–π—Å—Ç–≤–∏–π ‚Äî —Ç–æ–ª—å–∫–æ –Ω–∞ –º–æ–±–∏–ª–∫–∞—Ö/–ø–ª–∞–Ω—à–µ—Ç–∞—Ö */
    .bottomBar{
      position:fixed;left:0;right:0;bottom:0;
      padding:10px 10px calc(10px + env(safe-area-inset-bottom));
      background:rgba(15,18,32,.80);
      backdrop-filter: blur(10px);
      border-top:1px solid rgba(255,255,255,.10);
      display:none;
      z-index:999;
    }
    .bottomRow{
      max-width:1100px;margin:0 auto;
      display:grid;grid-template-columns:1fr 1fr 1fr 1fr;gap:8px;
    }
    .bottomRow button{padding:12px 10px;font-size:14px;border-radius:16px}
    @media (max-width: 980px){
      .bottomBar{display:block;}
      /* —á—Ç–æ–±—ã –≤–µ—Ä—Ö–Ω–∏–µ –∫–Ω–æ–ø–∫–∏ –Ω–µ –∑–∞–Ω–∏–º–∞–ª–∏ –º–µ—Å—Ç–æ –Ω–∞ –º–æ–±–∏–ª–µ */
      .actions{display:none;}
      .hd{align-items:flex-start}
    }
  </style>
</head>
<body>
<header>
  <div class="topline">
    <h1>–ö—Ä–∏–ø—Ç–æ–≥—Ä–∞–º–º–∞ ‚Äî —Ä–∞—Å—à–∏—Ñ—Ä—É–π —Ñ—Ä–∞–∑—É</h1>
    <div class="pill">–û—á–∫–∏: <b id="scorePill">0</b> ¬∑ –°–µ—Ä–∏—è: <b id="streakPill">0</b></div>
  </div>
</header>

<main>
  <section class="card">
    <div class="hd">
      <div class="title">
        <div style="font-weight:850;">–ó–∞–≥–∞–¥–∫–∞</div>
        <div class="subtitle" id="puzzleMeta">–ù–∞–∂–º–∏ –Ω–∞ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—É—é –±—É–∫–≤—É ‚Üí –≤—ã–±–µ—Ä–∏ –ø—Ä–∞–≤–∏–ª—å–Ω—É—é</div>
      </div>
      <div class="actions">
        <button class="primary" id="btnNew">–ù–æ–≤–∞—è</button>
        <button class="good" id="btnDaily">–ï–∂–µ–¥–Ω–µ–≤–Ω–∞—è</button>
        <button class="warn" id="btnHintLetter">–ü–æ–¥—Å–∫–∞–∑–∫–∞: –±—É–∫–≤–∞ (-20)</button>
        <button class="warn" id="btnHintWord">–ü–æ–¥—Å–∫–∞–∑–∫–∞: —Å–ª–æ–≤–æ (-50)</button>
        <button class="bad" id="btnResetMap">–°–±—Ä–æ—Å</button>
        <button id="btnCheck">–ü—Ä–æ–≤–µ—Ä–∏—Ç—å</button>
      </div>
    </div>

    <div class="body">
      <div class="cipher" id="cipherText"></div>

      <div style="margin-top:10px">
        <div class="subtitle">–†–∞–±–æ—á–µ–µ –ø–æ–ª–µ (–Ω–∞–∂–∏–º–∞–π –Ω–∞ –±–ª–æ–∫–∏):</div>
        <div class="grid" id="cipherGrid"></div>
      </div>

      <div class="msg" id="msg">–í—ã–±–µ—Ä–∏ –±—É–∫–≤—É –≤ —Ç–µ–∫—Å—Ç–µ –∏ –Ω–∞–∑–Ω–∞—á—å –µ–π —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ –Ω–∞ –∫–ª–∞–≤–∏–∞—Ç—É—Ä–µ —Å–Ω–∏–∑—É. ‚å´ ‚Äî –æ—á–∏—Å—Ç–∏—Ç—å –≤—ã–±—Ä–∞–Ω–Ω—É—é –±—É–∫–≤—É.</div>
    </div>

    <div class="footerNote">
      –ü–æ–¥—Å–∫–∞–∑–∫–∞: –≤ –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞–º–º–µ <b>–æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–µ –±—É–∫–≤—ã</b> –≤—Å–µ–≥–¥–∞ –æ–∑–Ω–∞—á–∞—é—Ç <b>–æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ –Ω–∞—Å—Ç–æ—è—â–∏–µ –±—É–∫–≤—ã</b>.
    </div>
  </section>

  <aside class="card">
    <div class="hd">
      <div class="title">
        <div style="font-weight:850;">–ü–∞–Ω–µ–ª—å</div>
        <div class="subtitle">–°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è –∏ –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞</div>
      </div>
      <div class="actions">
        <button id="btnReveal">–ü–æ–∫–∞–∑–∞—Ç—å –æ—Ç–≤–µ—Ç</button>
      </div>
    </div>

    <div class="body panel">
      <div class="statRow">
        <div class="stat">
          <div class="k">–ü—Ä–æ–≥—Ä–µ—Å—Å</div>
          <div class="v"><span id="progressVal">0</span>%</div>
        </div>
        <div class="stat">
          <div class="k">–û—à–∏–±–æ–∫ (–ø—Ä–æ–≤–µ—Ä–∫–∞)</div>
          <div class="v"><span id="errorsVal">0</span></div>
        </div>
      </div>

      <div class="mapping">
        <h3>–°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è (—à–∏—Ñ—Ä ‚Üí –±—É–∫–≤–∞)</h3>
        <div class="mapGrid" id="mapGrid"></div>
      </div>

      <div class="kbd">
        <h3>–ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞</h3>
        <div class="keys" id="keys"></div>
      </div>

      <div class="msg" id="smallNote">
        –°–æ–≤–µ—Ç: –Ω–∞—á–Ω–∏ —Å —á–∞—Å—Ç—ã—Ö –±—É–∫–≤ ‚Äî –û, –ê, –ï, –ò, –ù, –¢, –°.
      </div>
    </div>
  </aside>
</main>

<!-- –ù–∏–∂–Ω—è—è –ø–∞–Ω–µ–ª—å –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö -->
<div class="bottomBar">
  <div class="bottomRow">
    <button class="primary" id="mNew">–ù–æ–≤–∞—è</button>
    <button class="good" id="mDaily">–ï–∂–µ–¥–Ω–µ–≤–Ω.</button>
    <button class="warn" id="mHint">–ë—É–∫–≤–∞</button>
    <button id="mCheck">–ü—Ä–æ–≤–µ—Ä–∏—Ç—å</button>
  </div>
  <div class="bottomRow" style="margin-top:8px;grid-template-columns:1fr 1fr 1fr;">
    <button class="warn" id="mWord">–°–ª–æ–≤–æ</button>
    <button class="bad" id="mReset">–°–±—Ä–æ—Å</button>
    <button id="mReveal">–û—Ç–≤–µ—Ç</button>
  </div>
</div>

<script>
(() => {
  const QUOTES = [
    "–£–°–ü–ï–• –ü–†–ò–•–û–î–ò–¢ –ö –¢–ï–ú –ö–¢–û –î–ï–ô–°–¢–í–£–ï–¢",
    "–ë–û–õ–¨–®–û–ô –ü–£–¢–¨ –ù–ê–ß–ò–ù–ê–ï–¢–°–Ø –° –ü–ï–†–í–û–ì–û –®–ê–ì–ê",
    "–ó–ù–ê–ù–ò–Ø –≠–¢–û –°–ò–õ–ê",
    "–°–ï–ì–û–î–ù–Ø –õ–£–ß–®–ï –ß–ï–ú –ó–ê–í–¢–†–ê",
    "–î–ò–°–¶–ò–ü–õ–ò–ù–ê –í–ê–ñ–ù–ï–ï –ú–û–¢–ò–í–ê–¶–ò–ò",
    "–û–®–ò–ë–ö–ò –≠–¢–û –ß–ê–°–¢–¨ –û–ë–£–ß–ï–ù–ò–Ø",
    "–ú–ê–õ–´–ï –®–ê–ì–ò –î–ê–Æ–¢ –ë–û–õ–¨–®–ò–ï –†–ï–ó–£–õ–¨–¢–ê–¢–´",
    "–¢–ï–†–ü–ï–ù–ò–ï –ò –¢–†–£–î –í–°–ï –ü–ï–†–ï–¢–†–£–¢",
    "–ö–¢–û –ù–ï –†–ò–°–ö–£–ï–¢ –¢–û–¢ –ù–ï –í–´–ò–ì–†–´–í–ê–ï–¢",
    "–ü–õ–ê–ù –ë–ï–ó –î–ï–ô–°–¢–í–ò–Ø –≠–¢–û –ú–ï–ß–¢–ê",
    "–õ–£–ß–®–ï –°–î–ï–õ–ê–¢–¨ –ü–õ–û–•–û –ß–ï–ú –ù–ï –°–î–ï–õ–ê–¢–¨ –í–û–û–ë–©–ï",
    "–î–ï–ù–¨–ì–ò –õ–Æ–ë–Ø–¢ –°–ß–ï–¢",
    "–î–û–í–ï–†–Ø–ô –ù–û –ü–†–û–í–ï–†–Ø–ô",
    "–í–†–ï–ú–Ø –≠–¢–û –°–ê–ú–´–ô –î–û–†–û–ì–û–ô –†–ï–°–£–†–°",
    "–¢–´ –°–¢–ê–ù–û–í–ò–®–¨–°–Ø –¢–ï–ú –ß–¢–û –ü–û–í–¢–û–†–Ø–ï–®–¨ –ö–ê–ñ–î–´–ô –î–ï–ù–¨"
  ];

  const RU = "–ê–ë–í–ì–î–ï–Å–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø";
  const LETTER_SET = new Set(RU.split(""));
  const STORAGE_KEY = "cryptogram_mobile_v1";

  let state = loadState() || { score: 0, streak: 0, lastSolvedDaily: null, current: null };
  if (!state.current) { state.current = makeRandomPuzzle(); saveState(); }

  const elCipherText = document.getElementById("cipherText");
  const elCipherGrid = document.getElementById("cipherGrid");
  const elMsg = document.getElementById("msg");
  const elMapGrid = document.getElementById("mapGrid");
  const elKeys = document.getElementById("keys");
  const elProgressVal = document.getElementById("progressVal");
  const elErrorsVal = document.getElementById("errorsVal");
  const elScorePill = document.getElementById("scorePill");
  const elStreakPill = document.getElementById("streakPill");
  const elPuzzleMeta = document.getElementById("puzzleMeta");
  const elSmallNote = document.getElementById("smallNote");

  const btnNew = document.getElementById("btnNew");
  const btnDaily = document.getElementById("btnDaily");
  const btnHintLetter = document.getElementById("btnHintLetter");
  const btnHintWord = document.getElementById("btnHintWord");
  const btnResetMap = document.getElementById("btnResetMap");
  const btnCheck = document.getElementById("btnCheck");
  const btnReveal = document.getElementById("btnReveal");

  // Mobile bottom buttons
  const mNew = document.getElementById("mNew");
  const mDaily = document.getElementById("mDaily");
  const mHint = document.getElementById("mHint");
  const mCheck = document.getElementById("mCheck");
  const mWord = document.getElementById("mWord");
  const mReset = document.getElementById("mReset");
  const mReveal = document.getElementById("mReveal");

  let activeCipherLetter = null;

  function todayISO(){ const d=new Date(); return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,"0")}-${String(d.getDate()).padStart(2,"0")}`; }
  function hashStringToInt(s){ let h=2166136261; for(let i=0;i<s.length;i++){ h^=s.charCodeAt(i); h=Math.imul(h,16777619);} return (h>>>0); }
  function seededRandom(seed){ let t=seed>>>0; return function(){ t+=0x6D2B79F5; let x=Math.imul(t^(t>>>15),1|t); x^=x+Math.imul(x^(x>>>7),61|x); return ((x^(x>>>14))>>>0)/4294967296; }; }
  function pickRandom(arr,rnd=Math.random){ return arr[Math.floor(rnd()*arr.length)]; }
  function normalizeText(s){ return s.toUpperCase().replace(/\s+/g," ").trim(); }

  function makeSubstitutionMap(rnd=Math.random){
    const letters=RU.split(""); const perm=letters.slice();
    for(let i=perm.length-1;i>0;i--){ const j=Math.floor(rnd()*(i+1)); [perm[i],perm[j]]=[perm[j],perm[i]]; }
    for(let i=0;i<letters.length;i++){ if(perm[i]===letters[i]){ const j=(i+1)%letters.length; [perm[i],perm[j]]=[perm[j],perm[i]]; } }
    const sub={}; for(let i=0;i<letters.length;i++) sub[letters[i]]=perm[i]; return sub;
  }
  function encrypt(plain,sub){ let out=""; for(const ch of plain){ out += LETTER_SET.has(ch) ? sub[ch] : ch; } return out; }
  function invertMap(sub){ const inv={}; for(const [p,c] of Object.entries(sub)) inv[c]=p; return inv; }
  function getUniqueCipherLetters(cipher){ const set=new Set(); for(const ch of cipher) if(LETTER_SET.has(ch)) set.add(ch); return Array.from(set).sort(); }
  function applyGuessToCipherText(cipher,guess){ let out=""; for(const ch of cipher){ out += LETTER_SET.has(ch) ? (guess[ch]||"¬∑") : ch; } return out; }
  function countFilled(cipher,guess){ let total=0,filled=0; for(const ch of cipher){ if(LETTER_SET.has(ch)){ total++; if(guess[ch]) filled++; } } return {total,filled}; }
  function getWordsIndices(text){
    const res=[]; let i=0;
    while(i<text.length){
      while(i<text.length && !LETTER_SET.has(text[i])) i++;
      if(i>=text.length) break;
      const start=i;
      while(i<text.length && LETTER_SET.has(text[i])) i++;
      res.push({start,end:i});
    }
    return res;
  }

  function showMessage(text,kind=""){ elMsg.className="msg"+(kind?" "+kind:""); elMsg.textContent=text; }
  function showSmall(text,kind=""){ elSmallNote.className="msg"+(kind?" "+kind:""); elSmallNote.textContent=text; }

  function loadState(){
    try{
      const raw=localStorage.getItem(STORAGE_KEY);
      if(!raw) return null;
      const s=JSON.parse(raw);
      if(s?.current?.revealed && Array.isArray(s.current.revealed)) s.current.revealed=new Set(s.current.revealed);
      else if(s?.current) s.current.revealed=new Set();
      return s;
    }catch{ return null; }
  }
  function saveState(){
    const s=structuredClone(state);
    if(s?.current?.revealed instanceof Set) s.current.revealed=Array.from(s.current.revealed);
    localStorage.setItem(STORAGE_KEY, JSON.stringify(s));
  }

  function makeRandomPuzzle(){
    const plain=normalizeText(pickRandom(QUOTES));
    const sub=makeSubstitutionMap(Math.random);
    const cipher=encrypt(plain,sub);
    return { mode:"new", id:"rnd_"+Date.now(), plain, cipher, sub, inv:invertMap(sub), guess:{}, revealed:new Set() };
  }
  function makeDailyPuzzle(){
    const day=todayISO(); const rnd=seededRandom(hashStringToInt("daily:"+day));
    const plain=normalizeText(pickRandom(QUOTES,rnd));
    const sub=makeSubstitutionMap(rnd);
    const cipher=encrypt(plain,sub);
    return { mode:"daily", id:"daily_"+day, plain, cipher, sub, inv:invertMap(sub), guess:{}, revealed:new Set() };
  }

  function render(){
    elScorePill.textContent=String(state.score);
    elStreakPill.textContent=String(state.streak);

    const modeLabel = state.current.mode==="daily" ? "–ï–∂–µ–¥–Ω–µ–≤–Ω–∞—è" : "–û–±—ã—á–Ω–∞—è";
    elPuzzleMeta.textContent = `${modeLabel} ¬∑ –ù–∞–∂–º–∏ –Ω–∞ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—É—é –±—É–∫–≤—É ‚Üí –≤—ã–±–µ—Ä–∏ –ø—Ä–∞–≤–∏–ª—å–Ω—É—é`;

    elCipherText.textContent =
      "–®–∏—Ñ—Ä:\n" + state.current.cipher + "\n\n–í–∞—à –æ—Ç–≤–µ—Ç:\n" +
      applyGuessToCipherText(state.current.cipher, state.current.guess);

    buildCipherGrid();
    buildMappingPanel();
    buildKeyboard();

    const {total,filled}=countFilled(state.current.cipher,state.current.guess);
    elProgressVal.textContent= total ? String(Math.floor(filled/total*100)) : "0";
    elErrorsVal.textContent="0";

    btnHintLetter.disabled = state.score < 20;
    btnHintWord.disabled = state.score < 50;
    mHint.disabled = state.score < 20;
    mWord.disabled = state.score < 50;

    if(state.current.mode==="daily"){
      const day=todayISO();
      if(state.lastSolvedDaily===day) showSmall("–°–µ–≥–æ–¥–Ω—è—à–Ω—è—è –µ–∂–µ–¥–Ω–µ–≤–Ω–∞—è –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞–º–º–∞ —É–∂–µ —Ä–µ—à–µ–Ω–∞. –ú–æ–∂–Ω–æ —Ä–µ—à–∞—Ç—å –æ–±—ã—á–Ω—ã–µ üôÇ","ok");
      else showSmall("–ï–∂–µ–¥–Ω–µ–≤–Ω–∞—è –∑–∞–¥–∞—á–∞: —Ä–µ—à–∏ —Å–µ–≥–æ–¥–Ω—è –∏ –ø–æ–ª—É—á–∏ –±–æ–Ω—É—Å +100 –æ—á–∫–æ–≤!","");
    }else{
      showSmall("–°–æ–≤–µ—Ç: –Ω–∞—á–Ω–∏ —Å —á–∞—Å—Ç—ã—Ö –±—É–∫–≤ ‚Äî –û, –ê, –ï, –ò, –ù, –¢, –°.","");
    }
  }

  function buildCipherGrid(){
    elCipherGrid.innerHTML="";
    const cipher=state.current.cipher;

    for(let i=0;i<cipher.length;i++){
      const ch=cipher[i];

      if(ch===" "){
        const div=document.createElement("div"); div.className="cell space";
        elCipherGrid.appendChild(div); continue;
      }
      if(!LETTER_SET.has(ch)){
        const div=document.createElement("div"); div.className="cell punct";
        div.textContent=ch; elCipherGrid.appendChild(div); continue;
      }

      const div=document.createElement("div");
      div.className="cell"+(state.current.guess[ch]?" mapped":"");
      div.dataset.c=ch;
      if(activeCipherLetter===ch) div.classList.add("active");

      const t=document.createElement("div"); t.className="top"; t.textContent=ch;
      const b=document.createElement("div"); b.className="bot"; b.textContent=state.current.guess[ch]||"¬∑";
      div.appendChild(t); div.appendChild(b);

      div.addEventListener("click", ()=>{
        activeCipherLetter = (activeCipherLetter===ch) ? null : ch;
        render();
      });

      elCipherGrid.appendChild(div);
    }
  }

  function buildMappingPanel(){
    elMapGrid.innerHTML="";
    const letters=getUniqueCipherLetters(state.current.cipher);
    for(const c of letters){
      const item=document.createElement("div");
      item.className="mapItem";
      const left=document.createElement("div"); left.className="left"; left.textContent=c+" ‚Üí";
      const right=document.createElement("div"); right.className="right"; right.textContent=state.current.guess[c]||"¬∑";
      item.appendChild(left); item.appendChild(right);
      item.addEventListener("click", ()=>{ activeCipherLetter=c; render(); });
      elMapGrid.appendChild(item);
    }
  }

  function buildKeyboard(){
    elKeys.innerHTML="";
    const makeKey=(label,onClick,extra="")=>{
      const k=document.createElement("div");
      k.className="key"+(extra?" "+extra:"");
      k.textContent=label;
      k.addEventListener("click", onClick);
      return k;
    };

    for(const L of RU){
      elKeys.appendChild(makeKey(L, ()=>assignLetter(L)));
    }
    elKeys.appendChild(makeKey("‚å´", ()=>clearActive(), "special"));
    elKeys.appendChild(makeKey("–û—á–∏—Å—Ç–∏—Ç—å –≤—Å—ë", ()=>resetMap(), "special"));
  }

  function assignLetter(plainLetter){
    if(!activeCipherLetter){ showMessage("–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏ –±—É–∫–≤—É –≤ —Ç–µ–∫—Å—Ç–µ (–≤–µ—Ä—Ö–Ω—è—è –º–∞–ª–µ–Ω—å–∫–∞—è).","warn"); return; }
    if(state.current.revealed.has(activeCipherLetter)){ showMessage("–≠—Ç–∞ –±—É–∫–≤–∞ –æ—Ç–∫—Ä—ã—Ç–∞ –ø–æ–¥—Å–∫–∞–∑–∫–æ–π –∏ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–∞.","warn"); return; }

    const existing = Object.entries(state.current.guess).find(([c,p])=>p===plainLetter && c!==activeCipherLetter);
    if(existing){ showMessage(`"${plainLetter}" —É–∂–µ –Ω–∞–∑–Ω–∞—á–µ–Ω–∞ –¥–ª—è "${existing[0]}". –û—á–∏—Å—Ç–∏ –µ—ë (‚å´) –∏–ª–∏ –≤—ã–±–µ—Ä–∏ –¥—Ä—É–≥—É—é.`,"warn"); return; }

    state.current.guess[activeCipherLetter]=plainLetter;
    saveState();
    showMessage(`–ù–∞–∑–Ω–∞—á–µ–Ω–æ: ${activeCipherLetter} ‚Üí ${plainLetter}`,"");
    render();
  }

  function clearActive(){
    if(!activeCipherLetter){ showMessage("–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏ –±—É–∫–≤—É –≤ —Ç–µ–∫—Å—Ç–µ.","warn"); return; }
    if(state.current.revealed.has(activeCipherLetter)){ showMessage("–≠—Ç–∞ –±—É–∫–≤–∞ –æ—Ç–∫—Ä—ã—Ç–∞ –ø–æ–¥—Å–∫–∞–∑–∫–æ–π –∏ –Ω–µ –æ—á–∏—â–∞–µ—Ç—Å—è.","warn"); return; }
    delete state.current.guess[activeCipherLetter];
    saveState();
    showMessage(`–û—á–∏—â–µ–Ω–æ: ${activeCipherLetter}`,"");
    render();
  }

  function resetMap(){
    const keep={};
    for(const c of state.current.revealed) keep[c]=state.current.inv[c];
    state.current.guess=keep;
    activeCipherLetter=null;
    saveState();
    showMessage("–°–±—Ä–æ—Å –≤—ã–ø–æ–ª–Ω–µ–Ω. –ü–æ–¥—Å–∫–∞–∑–∫–∞–º–∏ –æ—Ç–∫—Ä—ã—Ç—ã–µ –±—É–∫–≤—ã —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã.","");
    render();
  }

  function isFullySolved(){
    const letters=getUniqueCipherLetters(state.current.cipher);
    for(const c of letters){
      const need=state.current.inv[c];
      const g=state.current.guess[c];
      if(!g || g!==need) return false;
    }
    return letters.length>0;
  }

  function checkSolution(){
    const cipher=state.current.cipher;
    const guess=state.current.guess;
    const inv=state.current.inv;

    let errors=0, compared=0;
    const cells=elCipherGrid.querySelectorAll(".cell[data-c]");
    cells.forEach(cell=>cell.classList.remove("correct","wrong"));

    for(const cell of cells){
      const c=cell.dataset.c;
      const g=guess[c];
      if(!g) continue;
      compared++;
      if(g===inv[c]) cell.classList.add("correct");
      else { cell.classList.add("wrong"); errors++; }
    }

    elErrorsVal.textContent=String(errors);

    if(compared===0){ showMessage("–ü–æ–∫–∞ –Ω–µ—á–µ–≥–æ –ø—Ä–æ–≤–µ—Ä—è—Ç—å: –Ω–∞–∑–Ω–∞—á—å —Ö–æ—Ç—è –±—ã –æ–¥–Ω—É –±—É–∫–≤—É.","warn"); return; }
    if(isFullySolved()){ onSolved(); return; }

    if(errors===0) showMessage("–ü—Ä–æ–≤–µ—Ä–∫–∞: –æ—à–∏–±–æ–∫ –Ω–µ—Ç. –ü—Ä–æ–¥–æ–ª–∂–∞–π üôÇ","ok");
    else showMessage(`–ü—Ä–æ–≤–µ—Ä–∫–∞: –æ—à–∏–±–æ–∫ ‚Äî ${errors}. –ò—Å–ø—Ä–∞–≤—å –≤—ã–¥–µ–ª–µ–Ω–Ω—ã–µ –±—É–∫–≤—ã.`,"bad");
  }

  function onSolved(){
    const base=60;
    let bonus=0;
    if(state.current.mode==="daily"){
      const day=todayISO();
      if(state.lastSolvedDaily!==day){ bonus=100; state.lastSolvedDaily=day; }
    }
    state.streak=(state.streak||0)+1;
    state.score += base + bonus;
    saveState();
    showMessage(`‚úÖ –†–µ—à–µ–Ω–æ! +${base}${bonus?(" +"+bonus+" (–µ–∂–µ–¥–Ω–µ–≤–Ω—ã–π –±–æ–Ω—É—Å)"):""} –æ—á–∫–æ–≤. –°–µ—Ä–∏—è: ${state.streak}`,"ok");
    render();
  }

  function revealAnswer(){
    const letters=getUniqueCipherLetters(state.current.cipher);
    for(const c of letters) state.current.guess[c]=state.current.inv[c];
    activeCipherLetter=null;
    saveState();
    showMessage("–û—Ç–≤–µ—Ç –ø–æ–∫–∞–∑–∞–Ω. –ù–∞–∂–º–∏ ¬´–ù–æ–≤–∞—è¬ª –∏ —Ä–µ—à–∞–π –¥–∞–ª—å—à–µ.","warn");
    render();
  }

  function hintOneLetter(){
    if(state.score<20){ showMessage("–ù–µ —Ö–≤–∞—Ç–∞–µ—Ç –æ—á–∫–æ–≤ (–Ω—É–∂–Ω–æ 20).","warn"); return; }
    const letters=getUniqueCipherLetters(state.current.cipher);
    const candidates=letters.filter(c=>!state.current.guess[c]);
    if(!candidates.length){ showMessage("–í—Å–µ –±—É–∫–≤—ã —É–∂–µ –Ω–∞–∑–Ω–∞—á–µ–Ω—ã.","warn"); return; }
    const c=candidates[Math.floor(Math.random()*candidates.length)];
    const correct=state.current.inv[c];
    state.score-=20;
    state.current.guess[c]=correct;
    state.current.revealed.add(c);
    activeCipherLetter=c;
    saveState();
    showMessage(`–ü–æ–¥—Å–∫–∞–∑–∫–∞: ${c} ‚Üí ${correct} (–∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–æ)`,"ok");
    render();
  }

  function hintOneWord(){
    if(state.score<50){ showMessage("–ù–µ —Ö–≤–∞—Ç–∞–µ—Ç –æ—á–∫–æ–≤ (–Ω—É–∂–Ω–æ 50).","warn"); return; }
    const cipher=state.current.cipher;
    const words=getWordsIndices(cipher);
    if(!words.length){ showMessage("–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ —Å–ª–æ–≤–æ.","warn"); return; }

    // –≤—ã–±—Ä–∞—Ç—å —Å–ª–æ–≤–æ, –≥–¥–µ –µ—Å—Ç—å –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–µ –±—É–∫–≤—ã
    const shuffled=words.slice().sort(()=>Math.random()-0.5);
    let target=null;
    for(const w of shuffled){
      let hasUnknown=false;
      for(let i=w.start;i<w.end;i++){
        const ch=cipher[i];
        if(LETTER_SET.has(ch) && !state.current.guess[ch]) { hasUnknown=true; break; }
      }
      if(hasUnknown){ target=w; break; }
    }
    if(!target){ showMessage("–í—Å–µ —Å–ª–æ–≤–∞ —É–∂–µ —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–∏ —Ä–∞—Å–∫—Ä—ã—Ç—ã.","warn"); return; }

    state.score-=50;
    for(let i=target.start;i<target.end;i++){
      const c=cipher[i];
      if(!LETTER_SET.has(c)) continue;
      state.current.guess[c]=state.current.inv[c];
      state.current.revealed.add(c);
    }
    activeCipherLetter=null;
    saveState();
    showMessage("–ü–æ–¥—Å–∫–∞–∑–∫–∞: –æ–¥–Ω–æ —Å–ª–æ–≤–æ —Ä–∞—Å–∫—Ä—ã—Ç–æ (–±—É–∫–≤—ã –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã).","ok");
    render();
  }

  // Buttons
  const doNew = ()=>{ state.current=makeRandomPuzzle(); activeCipherLetter=null; saveState(); showMessage("–ù–æ–≤–∞—è –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞–º–º–∞ —Å–æ–∑–¥–∞–Ω–∞.",""); render(); };
  const doDaily = ()=>{ state.current=makeDailyPuzzle(); activeCipherLetter=null; saveState(); showMessage("–ï–∂–µ–¥–Ω–µ–≤–Ω–∞—è –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞–º–º–∞ –∑–∞–≥—Ä—É–∂–µ–Ω–∞.",""); render(); };

  btnNew?.addEventListener("click", doNew);
  btnDaily?.addEventListener("click", doDaily);
  btnHintLetter?.addEventListener("click", hintOneLetter);
  btnHintWord?.addEventListener("click", hintOneWord);
  btnResetMap?.addEventListener("click", resetMap);
  btnCheck?.addEventListener("click", checkSolution);
  btnReveal?.addEventListener("click", revealAnswer);

  // Mobile buttons
  mNew.addEventListener("click", doNew);
  mDaily.addEventListener("click", doDaily);
  mHint.addEventListener("click", hintOneLetter);
  mWord.addEventListener("click", hintOneWord);
  mReset.addEventListener("click", resetMap);
  mCheck.addEventListener("click", checkSolution);
  mReveal.addEventListener("click", revealAnswer);

  // Physical keyboard support (Android with BT keyboard / desktop)
  window.addEventListener("keydown",(e)=>{
    if(e.key==="Backspace"){ e.preventDefault(); clearActive(); return; }
    if(e.key==="Escape"){ activeCipherLetter=null; showMessage("–í—ã–±–æ—Ä —Å–Ω—è—Ç.",""); render(); return; }
    const upper=e.key.toUpperCase();
    if(upper.length===1 && LETTER_SET.has(upper)) assignLetter(upper);
  });

  // Ensure revealed is Set
  if(!(state.current.revealed instanceof Set)) state.current.revealed = new Set(Array.isArray(state.current.revealed)?state.current.revealed:[]);
  render();
})();
</script>
</body>
</html>
